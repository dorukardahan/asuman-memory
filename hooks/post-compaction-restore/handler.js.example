/**
 * post-compaction-restore — Two-phase compaction recovery hook.
 *
 * Phase 1 (after_compaction): Write a compaction flag file with metadata.
 * Phase 2 (agent:bootstrap): If flag is recent (< 2hrs), inject snapshot
 *   as COMPACTION_RECOVERY bootstrap file.
 *
 * Previously this hook was misnamed — it fired on every bootstrap, not
 * specifically after compaction. Now it correctly uses after_compaction
 * for the write phase. [S11, 2026-02-17]
 */

import fs from "node:fs/promises";
import path from "node:path";

const TWO_HOURS_MS = 2 * 60 * 60 * 1000;
const DEFAULT_WORKSPACE_DIR =
  process.env.OPENCLAW_WORKSPACE_DIR || "/path/to/openclaw/workspace";

// --- Phase 1: after_compaction — record that compaction happened ---
async function handleCompaction(event) {
  const context = event.context || {};
  const workspaceDir = context.workspaceDir || context.cfg?.workspace?.dir || DEFAULT_WORKSPACE_DIR;
  const flagPath = path.join(workspaceDir, "memory", "compaction-flag.json");

  const flag = {
    timestamp: new Date().toISOString(),
    messageCount: event.messageCount || 0,
    compactedCount: event.compactedCount || 0,
    tokenCount: event.tokenCount || null,
    sessionFile: event.sessionFile || null,
  };

  try {
    await fs.mkdir(path.join(workspaceDir, "memory"), { recursive: true });
    await fs.writeFile(flagPath, JSON.stringify(flag, null, 2), "utf-8");
    console.warn(
      `[post-compaction-restore] compaction recorded: ${flag.compactedCount} messages compacted`
    );
  } catch (err) {
    console.warn(`[post-compaction-restore] failed to write flag: ${err.message}`);
  }
}

// --- Phase 2: agent:bootstrap — restore if compaction was recent ---
async function handleBootstrap(event) {
  const context = event.context;
  if (!context || !context.bootstrapFiles) return;

  const workspaceDir = context.workspaceDir || context.cfg?.workspace?.dir || DEFAULT_WORKSPACE_DIR;
  const flagPath = path.join(workspaceDir, "memory", "compaction-flag.json");
  const snapshotPath = path.join(workspaceDir, "memory", "critical-context-snapshot.json");

  // Check if compaction happened recently
  let compactionRecent = false;
  try {
    const flagStat = await fs.stat(flagPath);
    compactionRecent = Date.now() - flagStat.mtimeMs < TWO_HOURS_MS;
    if (!compactionRecent) {
      console.warn("[post-compaction-restore] compaction flag too old, skipping");
      return;
    }
  } catch {
    // No flag file = no recent compaction, also check snapshot directly
    // (backward compat with old behavior)
  }

  try {
    const stat = await fs.stat(snapshotPath);
    const ageMs = Date.now() - stat.mtimeMs;
    console.warn(
      `[post-compaction-restore] snapshot age: ${Math.round(ageMs / 60000)}min, compaction_recent=${compactionRecent}`
    );

    // Only restore if snapshot is less than 2 hours old
    if (ageMs > TWO_HOURS_MS) {
      console.warn("[post-compaction-restore] snapshot too old, skipping");
      return;
    }

    const raw = await fs.readFile(snapshotPath, "utf-8");
    const snapshot = JSON.parse(raw);

    if (!snapshot.recentMessages || snapshot.recentMessages.length === 0) {
      console.warn("[post-compaction-restore] no messages in snapshot");
      return;
    }

    const lines = [
      "# Previous Session Context (Auto-Restored)",
      "",
      `> Snapshot from: ${snapshot.timestamp}`,
      `> Session: ${snapshot.sessionKey || "unknown"}`,
      compactionRecent ? "> Trigger: post-compaction recovery" : "> Trigger: session continuity",
      "",
      "**IMPORTANT**: This context was auto-restored from the previous session.",
      "Continue the conversation naturally. Do NOT greet as if starting a new day.",
      "If the user was mid-task, pick up where they left off.",
      "",
      "## Last Messages",
      "",
    ];

    for (const msg of snapshot.recentMessages) {
      lines.push(`**${msg.role}**: ${msg.text}`);
      lines.push("");
    }

    context.bootstrapFiles.push({
      name: "COMPACTION_RECOVERY",
      path: "COMPACTION_RECOVERY",
      content: lines.join("\n"),
    });
    console.warn(
      `[post-compaction-restore] injected COMPACTION_RECOVERY (${snapshot.recentMessages.length} msgs)`
    );
  } catch (err) {
    console.warn(`[post-compaction-restore] ${err.code || err.message}`);
  }
}

// --- Router: dispatch based on event type ---
const postCompactionRestoreHook = async (event) => {
  // Phase 1: after_compaction event
  if (event.type === "compaction" || event.action === "after_compaction") {
    return handleCompaction(event);
  }

  // Also handle the direct runner call pattern (runAfterCompaction passes data directly)
  if (event.compactedCount !== undefined && event.messageCount !== undefined) {
    return handleCompaction(event);
  }

  // Phase 2: agent:bootstrap
  if (event.type === "agent" && event.action === "bootstrap") {
    return handleBootstrap(event);
  }
};

export default postCompactionRestoreHook;
