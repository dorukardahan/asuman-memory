/**
 * session-end-capture hook — Capture session content on session end.
 */

import fs from "node:fs/promises";
import path from "node:path";
import { readFileSync, readdirSync } from "node:fs";

const MEMORY_API = "http://localhost:8787/v1";
const API_KEY_PATH = process.env.AGENT_MEMORY_API_KEY_FILE || `${process.env.HOME}/.noldomem/memory-api-key`;
let _memoryApiKey = "";
try { _memoryApiKey = readFileSync(API_KEY_PATH, "utf-8").trim(); } catch (e) { console.warn("[session-end-capture] error:", e.message || e); }

const OPENCLAW_DIR = process.env.OPENCLAW_DIR || `${process.env.HOME}/.openclaw`;

const SUGGESTION_PATTERNS = [/önerim/i, /ekleyelim/i, /suggest/i, /recommend/i];
const VERIFICATION_TOOL_PATTERNS = [/exec/i, /read/i, /web_fetch/i];

function isSuggestionText(text = "") {
  return SUGGESTION_PATTERNS.some((p) => p.test(text));
}

function hasVerificationSignal(entry = {}) {
  const haystack = JSON.stringify(entry || {});
  return VERIFICATION_TOOL_PATTERNS.some((p) => p.test(haystack));
}

async function detectUnverifiedSuggestion(sessionFilePath) {
  try {
    const raw = await fs.readFile(sessionFilePath, "utf-8");
    const lines = raw.trim().split("
").filter(Boolean);
    const entries = lines.map((line) => {
      try { return JSON.parse(line); } catch (e) { console.warn("[session-end-capture] error:", e.message || e); return null; }
    }).filter(Boolean);

    let hasPriorVerification = false;
    for (const entry of entries) {
      if (hasVerificationSignal(entry)) {
        hasPriorVerification = true;
        continue;
      }

      if (entry?.type !== "message") continue;
      const role = entry?.message?.role;
      if (role !== "assistant") continue;

      const content = entry?.message?.content;
      const text = Array.isArray(content)
        ? content.find((c) => c.type === "text")?.text
        : content;

      if (isSuggestionText(text || "") && !hasPriorVerification) {
        return true;
      }
    }
  } catch (e) { console.warn("[session-end-capture] error:", e.message || e); }
  return false;
}

function findSessionFile(sessionId, agentId = "main") {
  if (!sessionId) return null;

  // Search order: per-agent dir first, then global fallback
  const searchDirs = [
    path.join(OPENCLAW_DIR, "agents", agentId, "sessions"),
    path.join(OPENCLAW_DIR, "sessions"),
  ];

  for (const sessionsDir of searchDirs) {
    try {
      const files = readdirSync(sessionsDir);
      for (const f of files) {
        if (f.includes(sessionId) && f.endsWith(".jsonl")) {
          return path.join(sessionsDir, f);
        }
      }
    } catch (e) { console.warn("[session-end-capture] error:", e.message || e); }
  }
  return null;
}

async function getSessionMessages(sessionFilePath, count = 15) {
  try {
    const raw = await fs.readFile(sessionFilePath, "utf-8");
    const lines = raw.trim().split("\n");
    const messages = [];

    for (const line of lines) {
      try {
        const entry = JSON.parse(line);
        if (entry.type !== "message") continue;
        const msg = entry.message;
        if (!msg || !msg.content) continue;

        const role = msg.role;
        if (role !== "user" && role !== "assistant") continue;

        const text = Array.isArray(msg.content)
          ? msg.content.find((c) => c.type === "text")?.text
          : msg.content;

        if (text && text.length > 10 && !text.startsWith("/")) {
          messages.push({ role, text: text.slice(0, 1000) });
        }
      } catch (e) { console.warn("[session-end-capture] error:", e.message || e); }
    }

    return messages.slice(-count);
  } catch (e) {
    console.warn("[session-end-capture] error:", e.message || e);
    return [];
  }
}

function buildQAPairs(messages) {
  const pairs = [];
  for (let i = 0; i < messages.length - 1; i++) {
    if (messages[i].role === "user" && messages[i + 1].role === "assistant") {
      pairs.push({
        role: "qa_pair",
        text: `User: ${messages[i].text}\nAssistant: ${messages[i + 1].text}`,
      });
      i++;
    } else {
      pairs.push(messages[i]);
    }
  }
  const lastMsg = messages[messages.length - 1];
  if (lastMsg && (pairs.length === 0 || pairs[pairs.length - 1].text !== lastMsg.text)) {
    pairs.push(lastMsg);
  }
  return pairs;
}


async function checkPatternEscalation(agent, tag, apiKey) {
  try {
    const resp = await fetch('http://localhost:8787/v1/recall', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-API-Key': apiKey },
      body: JSON.stringify({ query: tag, agent, limit: 10, memory_type: 'lesson' })
    });
    const data = await resp.json();
    const sameTag = (data.results || []).filter(r => r.category === tag);

    if (sameTag.length >= 3) {
      const ruleText = `AUTO-RULE (${sameTag.length} occurrences): Pattern "${tag}" detected repeatedly. ` +
        `Original lessons: ${sameTag.slice(0, 3).map(r => (r.text || '').substring(0, 80)).join(' | ')}`;

      await fetch('http://localhost:8787/v1/store', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-API-Key': apiKey },
        body: JSON.stringify({
          content: ruleText,
          agent,
          source: 'auto_escalation',
          importance: 0.98,
          memory_type: 'rule',
          namespace: 'behavioral'
        })
      });
      console.warn(`[session-end-capture] Auto-escalated pattern "${tag}" to rule (${sameTag.length} lessons)`);
    }
  } catch (e) {
    console.warn('[session-end-capture] pattern escalation error:', e.message);
  }
}

const sessionEndCaptureHook = async (event, ctx) => {
  const sessionId = event?.sessionId || ctx?.sessionId;
  const agentId = ctx?.agentId || "main";

  if (!sessionId) return;

  const sessionFile = findSessionFile(sessionId, agentId);
  if (!sessionFile) {
    console.warn(`[session-end-capture] no session file found for ${sessionId}`);
    return;
  }

  const messages = await getSessionMessages(sessionFile, 15);
  if (messages.length < 2) return;

  const pairs = buildQAPairs(messages);

  try {
    await fetch(`${MEMORY_API}/capture`, {
      method: "POST",
      headers: { "Content-Type": "application/json", "X-API-Key": _memoryApiKey },
      body: JSON.stringify({
        messages: pairs.map((p) => ({ role: p.role || "assistant", text: p.text })),
        agent: agentId,
      }),
      signal: AbortSignal.timeout(30000),
    });
  } catch (err) {
    console.warn(`[session-end-capture] capture failed: ${err.message}`);
  }

  try {
    const shouldStoreAutoLesson = await detectUnverifiedSuggestion(sessionFile);
    if (shouldStoreAutoLesson) {
      await fetch(`${MEMORY_API}/store`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-API-Key": _memoryApiKey },
        body: JSON.stringify({
          text: "[Auto-Lesson][tag=verification] Suggested without verifiable check before recommendation.",
          category: "lesson",
          importance: 0.90,
          agent: agentId,
          source: "session_capture",
        }),
        signal: AbortSignal.timeout(10000),
      });

      // Check if pattern should be escalated to a rule
      await checkPatternEscalation(agentId, "verification", _memoryApiKey);
    }
  } catch (err) {
    console.warn(`[session-end-capture] auto-lesson failed: ${err.message}`);
  }

  try {
    const workspaceDir = agentId === "main" ? process.env.OPENCLAW_WORKSPACE || `${process.env.HOME}/.openclaw/workspace` : `$HOME/.openclaw/workspace-${agentId}`;
    const memoryDir = path.join(workspaceDir, "memory");
    await fs.mkdir(memoryDir, { recursive: true });

    const lines = [
      "# Last Session Summary",
      "",
      `- **Session ID:** ${sessionId}`,
      `- **Agent:** ${agentId}`,
      `- **Captured:** ${new Date().toISOString()}`,
      "",
      "## Conversation",
      "",
    ];
    for (const m of messages.slice(-10)) {
      lines.push(`**${m.role}:** ${m.text.slice(0, 300)}`);
      lines.push("");
    }
    await fs.writeFile(path.join(memoryDir, "last-session.md"), lines.join("\n"), "utf-8");
  } catch (err) {
    console.warn(`[session-end-capture] write failed: ${err.message}`);
  }
};

export default sessionEndCaptureHook;
