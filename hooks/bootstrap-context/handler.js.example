import fs from "node:fs/promises";
import path from "node:path";

const MEMORY_API_BASE = process.env.MEMORY_API_URL || "http://localhost:8787";
const MEMORY_API = `${MEMORY_API_BASE}/v1`;
const MEMORY_API_KEY = process.env.MEMORY_API_KEY || "YOUR_MEMORY_API_KEY";
const DEFAULT_WORKSPACE_DIR =
  process.env.OPENCLAW_WORKSPACE_DIR || "/path/to/openclaw/workspace";

// === Character limits for bootstrap budget management ===
const MAX_MEMORY_CHARS = 8000;
const MAX_DAILY_CHARS = 6000;
const MAX_CROSSAGENT_CHARS = 2000;
const MAX_LAST_SESSION_CHARS = 2000;

const CRON_NOISE_PATTERNS = [/^\[cron:/i, /steward-engage/i, /steward-post/i, /\/steward-/i];

function isCronNoise(text = "") {
  return CRON_NOISE_PATTERNS.some((p) => p.test(text));
}

function truncateSection(text, maxChars) {
  if (text.length <= maxChars) return text;
  return text.slice(0, maxChars) + "\n... [truncated to " + maxChars + " chars]";
}

/**
 * Derive agent ID from workspace directory path.
 *   /path/to/openclaw/workspace        -> "main"
 *   /path/to/openclaw/workspace-bureau -> "bureau"
 */
function getAgentId(workspaceDir) {
  const base = path.basename(workspaceDir);
  if (base === "workspace") return "main";
  if (base.startsWith("workspace-")) return base.replace("workspace-", "");
  return "main";
}

async function fetchRecentMemories(agentId) {
  const queries = [
    "recent decisions and configuration changes",
    "last conversation summary and active work",
  ];

  const allResults = [];
  const seen = new Set();

  for (const q of queries) {
    try {
      const res = await fetch(`${MEMORY_API}/recall`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-API-Key": MEMORY_API_KEY,
        },
        body: JSON.stringify({
          query: agentId !== "main" ? `${agentId}: ${q}` : q,
          limit: 10,
          min_score: 0.005,
          agent: agentId,
        }),
        signal: AbortSignal.timeout(5000),
      });
      if (!res.ok) continue;
      const data = await res.json();
      const results = data.results || data.memories || [];
      for (const r of results) {
        const text = r.text || r.content || "";
        const key = text.slice(0, 120);
        if (!seen.has(key)) {
          seen.add(key);
          allResults.push(r);
        }
      }
    } catch {
      // non-critical
    }
  }

  return allResults;
}

async function fetchDecisionMemories(agentId) {
  try {
    const res = await fetch(`${MEMORY_API}/recall`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-Key": MEMORY_API_KEY,
      },
      body: JSON.stringify({
        query: "recent decisions, architectural choices, configuration changes",
        limit: 5,
        min_score: 0.01,
        agent: agentId,
      }),
      signal: AbortSignal.timeout(4000),
    });
    if (!res.ok) return null;
    const data = await res.json();
    return data.results || data.memories || [];
  } catch {
    return null;
  }
}

async function readLastSessionSummary(workspaceDir) {
  const filePath = path.join(workspaceDir, "memory", "last-session.md");
  try {
    const content = await fs.readFile(filePath, "utf-8");
    if (content.trim()) {
      return truncateSection(content.trim(), MAX_LAST_SESSION_CHARS);
    }
  } catch {
    // file may not exist yet
  }
  return null;
}

async function readDailyNotes(memoryDir) {
  const now = new Date();
  const today = now.toISOString().split("T")[0];
  const yesterday = new Date(now - 86400000).toISOString().split("T")[0];
  const parts = [];

  for (const date of [today, yesterday]) {
    try {
      const files = await fs.readdir(memoryDir);
      const matches = files.filter((f) => f.startsWith(date) && f.endsWith(".md"));
      for (const file of matches) {
        const content = await fs.readFile(path.join(memoryDir, file), "utf-8");
        if (content.trim()) parts.push(`## ${file}\n${content.trim()}`);
      }
    } catch {
      // directory may not exist yet
    }
  }
  return parts.join("\n\n");
}

const bootstrapContextHook = async (event) => {
  if (event.type !== "agent" || event.action !== "bootstrap") return;

  const context = event.context;
  if (!context || !context.bootstrapFiles) return;

  const workspaceDir = context.workspaceDir || context.cfg?.workspace?.dir || DEFAULT_WORKSPACE_DIR;
  const agentId = getAgentId(workspaceDir);
  const memoryDir = path.join(workspaceDir, "memory");

  console.warn(`[bootstrap-context] hook fired (agent=${agentId})`);

  const sections = [];

  // 1. Fetch recent memories from API (per-agent)
  const memories = await fetchRecentMemories(agentId);
  if (memories && memories.length > 0) {
    console.warn(`[bootstrap-context] fetched ${memories.length} memories for ${agentId}`);
    const memLines = ["# Recent Memory Recall\n"];
    let memChars = 0;
    for (const mem of memories) {
      const text = mem.text || mem.content || JSON.stringify(mem);
      if (isCronNoise(text)) continue;
      const cat = mem.category ? ` [${mem.category}]` : "";
      const strength = mem.strength ? ` (strength: ${mem.strength})` : "";
      const line = `- ${text.slice(0, 300)}${cat}${strength}`;
      memChars += line.length;
      if (memChars > MAX_MEMORY_CHARS) break;
      memLines.push(line);
    }
    sections.push(...memLines);
  } else {
    console.warn(`[bootstrap-context] no memories for ${agentId}`);
  }

  // 1b. Cross-agent recall for specialists
  if (agentId !== "main" && (!memories || memories.length < 5)) {
    try {
      const mainRes = await fetch(`${MEMORY_API}/recall`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-API-Key": MEMORY_API_KEY,
        },
        body: JSON.stringify({
          query: `recent decisions and context for ${agentId} tasks`,
          limit: 5,
          agent: "main",
        }),
        signal: AbortSignal.timeout(3000),
      });
      if (mainRes.ok) {
        const mainData = await mainRes.json();
        const mainMemories = mainData.results || [];
        if (mainMemories.length > 0) {
          console.warn(
            `[bootstrap-context] cross-agent: ${mainMemories.length} from main for ${agentId}`
          );
          const crossLines = ["\n# Main Agent Context\n"];
          let crossChars = 0;
          for (const mem of mainMemories.slice(0, 3)) {
            const t = mem.text || "";
            if (isCronNoise(t)) continue;
            const line = `- ${t.slice(0, 200)} [from main]`;
            crossChars += line.length;
            if (crossChars > MAX_CROSSAGENT_CHARS) break;
            crossLines.push(line);
          }
          sections.push(...crossLines);
        }
      }
    } catch {
      /* non-critical */
    }
  }

  // 1c. Decision-focused recall (second query)
  const decisions = await fetchDecisionMemories(agentId);
  if (decisions && decisions.length > 0) {
    // Deduplicate against already-fetched memories
    const existingTexts = new Set((memories || []).map((m) => (m.text || "").slice(0, 100)));
    const newDecisions = decisions.filter(
      (d) => !existingTexts.has((d.text || "").slice(0, 100))
    );
    if (newDecisions.length > 0) {
      console.warn(
        `[bootstrap-context] fetched ${newDecisions.length} unique decisions for ${agentId}`
      );
      const decLines = ["\n# Recent Decisions & Changes\n"];
      for (const dec of newDecisions.slice(0, 5)) {
        const text = dec.text || dec.content || "";
        if (isCronNoise(text)) continue;
        decLines.push(`- ${text.slice(0, 250)}`);
      }
      sections.push(...decLines);
    }
  }

  // 2. Read last session summary
  const lastSession = await readLastSessionSummary(workspaceDir);
  if (lastSession) {
    console.warn(`[bootstrap-context] read last-session.md (${lastSession.length} chars)`);
    sections.push("\n# Last Session Summary\n");
    sections.push(lastSession);
  }

  // 3. Read daily notes
  const dailyNotes = await readDailyNotes(memoryDir);
  if (dailyNotes) {
    const trimmedNotes = truncateSection(dailyNotes, MAX_DAILY_CHARS);
    console.warn(
      `[bootstrap-context] read daily notes (${dailyNotes.length} -> ${trimmedNotes.length} chars)`
    );
    sections.push("\n# Recent Daily Notes\n");
    sections.push(trimmedNotes);
  }

  if (sections.length === 0) {
    console.warn("[bootstrap-context] no content to inject");
    return;
  }

  const content = sections.join("\n");
  context.bootstrapFiles.push({
    name: "SESSION_CONTEXT",
    path: "SESSION_CONTEXT",
    content,
  });
  console.warn(`[bootstrap-context] injected SESSION_CONTEXT (${content.length} chars, agent=${agentId})`);
};

export default bootstrapContextHook;
