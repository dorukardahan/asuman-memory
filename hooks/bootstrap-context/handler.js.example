import fs from "node:fs/promises";
import path from "node:path";

const MEMORY_API = "http://localhost:8787/v1";
import { readFileSync } from "node:fs";
const API_KEY_PATH = process.env.AGENT_MEMORY_API_KEY_FILE || `${process.env.HOME}/.noldomem/memory-api-key`;
let _memoryApiKey = "";
try { _memoryApiKey = readFileSync(API_KEY_PATH, "utf-8").trim(); } catch (e) { console.warn("[bootstrap-context] error:", e.message || e); }

// === Character limits for bootstrap budget management ===
const MAX_MEMORY_CHARS = 8000;
const MAX_DAILY_CHARS = 6000;
const MAX_CROSSAGENT_CHARS = 2000;
const MAX_LAST_SESSION_CHARS = 2000;
const MAX_LESSON_CHARS = 3000;


const CRON_NOISE_PATTERNS = [
  /^\[cron:/i,
  /steward-engage/i,
  /steward-post/i,
  /\/steward-/i,
];

function isCronNoise(text = "") {
  return CRON_NOISE_PATTERNS.some((p) => p.test(text));
}

function truncateSection(text, maxChars) {
  if (text.length <= maxChars) return text;
  return text.slice(0, maxChars) + "\n... [truncated to " + maxChars + " chars]";
}


/**
 * Derive agent ID from workspace directory path.
 *   $HOME/.openclaw/workspace        -> "main"
 *   $HOME/.openclaw/workspace-bureau  -> "bureau"
 */
function getAgentId(workspaceDir) {
  const base = path.basename(workspaceDir);
  if (base === "workspace") return "main";
  if (base.startsWith("workspace-")) return base.replace("workspace-", "");
  return "main";
}

async function fetchRecentMemories(agentId, sessionKey) {
  const queries = [
    "recent decisions and configuration changes",
    "last conversation summary and active work",
  ];

  const allResults = [];
  const seen = new Set();

  for (const q of queries) {
    try {
      const res = await fetch(`${MEMORY_API}/recall`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-API-Key": _memoryApiKey },
        body: JSON.stringify({
          query: agentId !== "main" ? `${agentId}: ${q}` : q,
          limit: 10,
          min_score: 0.005,
          agent: agentId,
        }),
        signal: AbortSignal.timeout(5000),
      });
      if (!res.ok) continue;
      const data = await res.json();
      const results = data.results || data.memories || [];
      for (const r of results) {
        const text = r.text || r.content || "";
        const key = text.slice(0, 120);
        if (!seen.has(key)) {
          seen.add(key);
          allResults.push(r);
        }
      }
    } catch (e) { console.warn("[bootstrap-context] error:", e.message || e); }
  }

  return allResults;
}

async function fetchDecisionMemories(agentId) {
  try {
    const res = await fetch(`${MEMORY_API}/recall`, {
      method: "POST",
      headers: { "Content-Type": "application/json", "X-API-Key": _memoryApiKey },
      body: JSON.stringify({
        query: "recent decisions, architectural choices, configuration changes",
        limit: 5,
        min_score: 0.01,
        agent: agentId,
      }),
      signal: AbortSignal.timeout(4000),
    });
    if (!res.ok) return null;
    const data = await res.json();
    return data.results || data.memories || [];
  } catch (e) {
    console.warn("[bootstrap-context] error:", e.message || e);
    return null;
  }
}

async function fetchLessons(agentId) {
  try {
    const res = await fetch(`${MEMORY_API}/recall`, {
      method: "POST",
      headers: { "Content-Type": "application/json", "X-API-Key": _memoryApiKey },
      body: JSON.stringify({
        query: "behavioral lessons",
        limit: 20,
        min_score: 0.0,
        memory_type: "lesson",
        agent: agentId,
      }),
      signal: AbortSignal.timeout(4000),
    });
    if (!res.ok) return [];
    const data = await res.json();
    const results = data.results || data.memories || [];

    const sorted = results.sort((a, b) => {
      const imp = (Number(b.importance) || 0) - (Number(a.importance) || 0);
      if (imp !== 0) return imp;
      return (Number(b.created_at) || 0) - (Number(a.created_at) || 0);
    });

    const deduped = [];
    for (const item of sorted) {
      const text = (item.text || item.content || "").trim();
      if (!text) continue;
      const isDuplicate = deduped.some((existing) => {
        const prev = (existing.text || existing.content || "").trim();
        return prev.includes(text) || text.includes(prev);
      });
      if (!isDuplicate) deduped.push(item);
      if (deduped.length >= 5) break;
    }

    return deduped;
  } catch (e) {
    console.warn("[bootstrap-context] error:", e.message || e);
    return [];
  }
}

async function readLastSessionSummary(workspaceDir) {
  const filePath = path.join(workspaceDir, "memory", "last-session.md");
  try {
    const content = await fs.readFile(filePath, "utf-8");
    if (content.trim()) {
      return truncateSection(content.trim(), MAX_LAST_SESSION_CHARS);
    }
  } catch (e) {
    console.warn("[bootstrap-context] error:", e.message || e);
    // file may not exist yet
  }
  return null;
}

async function readDailyNotes(memoryDir) {
  const now = new Date();
  const today = now.toISOString().split("T")[0];
  const yesterday = new Date(now - 86400000).toISOString().split("T")[0];
  const parts = [];

  for (const date of [today, yesterday]) {
    try {
      const files = await fs.readdir(memoryDir);
      const matches = files.filter((f) => f.startsWith(date) && f.endsWith(".md"));
      for (const file of matches) {
        const content = await fs.readFile(path.join(memoryDir, file), "utf-8");
        if (content.trim()) parts.push(`## ${file}\n${content.trim()}`);
      }
    } catch (e) {
      console.warn("[bootstrap-context] error:", e.message || e);
      // directory may not exist yet
    }
  }
  return parts.join("\n\n");
}

const bootstrapContextHook = async (event) => {
  if (event.type !== "agent" || event.action !== "bootstrap") return;

  const context = event.context;
  if (!context || !context.bootstrapFiles) return;

  const workspaceDir =
    context.workspaceDir || context.cfg?.workspace?.dir || process.env.OPENCLAW_WORKSPACE || `${process.env.HOME}/.openclaw/workspace`;
  const agentId = getAgentId(workspaceDir);
  const memoryDir = path.join(workspaceDir, "memory");

  console.warn(`[bootstrap-context] hook fired (agent=${agentId})`);

  const sections = [];

  // 0. Fetch behavioral lessons FIRST (highest priority â€” always at top of context)
  const lessons = await fetchLessons(agentId);
  if (lessons.length > 0) {
    console.warn(`[bootstrap-context] fetched ${lessons.length} lessons for ${agentId}`);
    const lessonLines = ["# Critical Lessons (Behavioral Memory)\n"];
    let lessonChars = 0;
    for (const l of lessons) {
      const text = l.text || l.content || "";
      const line = `- ${text.slice(0, 400)}`;
      lessonChars += line.length;
      if (lessonChars > MAX_LESSON_CHARS) break;
      lessonLines.push(line);
    }
    lessonLines.push("");
    sections.push(...lessonLines);
  }

  // 1. Fetch recent memories from API (per-agent)
  const memories = await fetchRecentMemories(agentId, event.sessionKey);
  if (memories && memories.length > 0) {
    console.warn(`[bootstrap-context] fetched ${memories.length} memories for ${agentId}`);
    const memLines = ["# Recent Memory Recall\n"];
    let memChars = 0;
    for (const mem of memories) {
      const text = mem.text || mem.content || JSON.stringify(mem);
      if (isCronNoise(text)) continue;
      const cat = mem.category ? ` [${mem.category}]` : "";
      const strength = mem.strength ? ` (strength: ${mem.strength})` : "";
      const line = `- ${text.slice(0, 300)}${cat}${strength}`;
      memChars += line.length;
      if (memChars > MAX_MEMORY_CHARS) break;
      memLines.push(line);
    }
    sections.push(...memLines);
  } else {
    console.warn(`[bootstrap-context] no memories for ${agentId}`);
  }

  // 1b. Cross-agent recall for specialists
  if (agentId !== "main" && (!memories || memories.length < 5)) {
    try {
      const mainRes = await fetch(`${MEMORY_API}/recall`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-API-Key": _memoryApiKey },
        body: JSON.stringify({
          query: `recent decisions and context for ${agentId} tasks`,
          limit: 5,
          agent: "main",
        }),
        signal: AbortSignal.timeout(3000),
      });
      if (mainRes.ok) {
        const mainData = await mainRes.json();
        const mainMemories = mainData.results || [];
        if (mainMemories.length > 0) {
          console.warn(`[bootstrap-context] cross-agent: ${mainMemories.length} from main for ${agentId}`);
          const crossLines = ["\n# Main Agent Context\n"];
          let crossChars = 0;
          for (const mem of mainMemories.slice(0, 3)) {
            const t = mem.text || "";
        if (isCronNoise(t)) continue;
        const line = `- ${t.slice(0, 200)} [from main]`;
            crossChars += line.length;
            if (crossChars > MAX_CROSSAGENT_CHARS) break;
            crossLines.push(line);
          }
          sections.push(...crossLines);
        }
      }
    } catch (e) { console.warn("[bootstrap-context] error:", e.message || e); /* non-critical */ }
  }

  // 1c. Decision-focused recall (second query)
  const decisions = await fetchDecisionMemories(agentId);
  if (decisions && decisions.length > 0) {
    // Deduplicate against already-fetched memories
    const existingTexts = new Set((memories || []).map(m => (m.text || "").slice(0, 100)));
    const newDecisions = decisions.filter(d => !existingTexts.has((d.text || "").slice(0, 100)));
    if (newDecisions.length > 0) {
      console.warn(`[bootstrap-context] fetched ${newDecisions.length} unique decisions for ${agentId}`);
      const decLines = ["\n# Recent Decisions & Changes\n"];
      for (const dec of newDecisions.slice(0, 5)) {
        const text = dec.text || dec.content || "";
        if (isCronNoise(text)) continue;
        decLines.push(`- ${text.slice(0, 250)}`);
      }
      sections.push(...decLines);
    }
  }

  // 2. Read last session summary
  const lastSession = await readLastSessionSummary(workspaceDir);
  if (lastSession) {
    console.warn(`[bootstrap-context] read last-session.md (${lastSession.length} chars)`);
    sections.push("\n# Last Session Summary\n");
    sections.push(lastSession);
  }

  // 3. Read daily notes
  const dailyNotes = await readDailyNotes(memoryDir);
  if (dailyNotes) {
    const trimmedNotes = truncateSection(dailyNotes, MAX_DAILY_CHARS);
    console.warn(`[bootstrap-context] read daily notes (${dailyNotes.length} -> ${trimmedNotes.length} chars)`);
    sections.push("\n# Recent Daily Notes\n");
    sections.push(trimmedNotes);
  }

  if (sections.length === 0) {
    console.warn("[bootstrap-context] no content to inject");
    return;
  }

  const content = sections.join("\n");
  context.bootstrapFiles.push({
    name: "SESSION_CONTEXT",
    path: "SESSION_CONTEXT",
    content,
  });
  console.warn(`[bootstrap-context] injected SESSION_CONTEXT (${content.length} chars, agent=${agentId})`);
};

export default bootstrapContextHook;
