/**
 * after-tool-call hook — Capture important tool outputs to memory.
 *
 * Fires on every tool call completion. Only captures exec commands that
 * match operationally important patterns (deploy, git, config, errors).
 * Skips routine read-only commands to avoid noise.
 *
 * Created: 2026-02-17 [S6 — Memory Improvement Plan]
 */

import path from "node:path";

const MEMORY_API_BASE = process.env.MEMORY_API_URL || "http://localhost:8787";
const MEMORY_API = `${MEMORY_API_BASE}/v1`;
const MEMORY_API_KEY = process.env.MEMORY_API_KEY || "YOUR_MEMORY_API_KEY";
const DEFAULT_WORKSPACE_DIR =
  process.env.OPENCLAW_WORKSPACE_DIR || "/path/to/openclaw/workspace";

// Command patterns that indicate important operations
const IMPORTANT_CMD_PATTERNS = [
  /systemctl\s+(restart|stop|start|enable|disable)/i,
  /docker\s+(compose|build|push|pull|up|down|restart|stop|start)/i,
  /git\s+(push|merge|tag|commit|checkout\s+-b)/i,
  /apt(?:-get)?\s+(install|upgrade|remove|purge)/i,
  /npm\s+(publish|install|update|uninstall)/i,
  /pip3?\s+install/i,
  /curl\s+.*-X\s*(POST|PUT|DELETE|PATCH)/i,
  /ufw\s+(allow|deny|enable|disable|delete)/i,
  /iptables\s+-[AID]/i,
  /certbot/i,
  /(?:cp|mv|rm)\s+.*(?:\.env|\.conf|\.service|\.json|\.yaml|\.yml)/i,
  /sed\s+-i/i,
  /crontab\s+-[re]/i,
  /chmod|chown/i,
  /mkswap|swapon|swapoff/i,
  /resize2fs|growpart/i,
];

// Patterns to SKIP (noisy/routine read-only commands)
const SKIP_PATTERNS = [
  /^\s*(ls|cat|head|tail|wc|echo|pwd|date|whoami|hostname|id|uptime)\b/,
  /^\s*(grep|find|du|df|free|top|htop|ps|pgrep|lsof)\b/,
  /^\s*(curl\s+-s.*localhost.*health|curl\s+-s.*localhost.*stats)/i,
  /^\s*python3?\s+-c\s/,
  /^\s*sleep\b/,
  /warmup/i,
  /health.*check/i,
  /^\s*test\s/,
  /^\s*\[/, // test expressions
  /^\s*true\s*$/,
  /^\s*false\s*$/,
];

function getAgentId(workspaceDir) {
  const base = path.basename(workspaceDir || "");
  if (base === "workspace") return "main";
  if (base.startsWith("workspace-")) return base.replace("workspace-", "");
  return "main";
}

function shouldCapture(toolName, toolInput) {
  if (toolName !== "exec") return false;

  const cmd = (toolInput?.command || "").trim();
  if (!cmd || cmd.length < 3) return false;

  // Skip routine commands
  if (SKIP_PATTERNS.some((p) => p.test(cmd))) return false;

  // Capture important commands
  if (IMPORTANT_CMD_PATTERNS.some((p) => p.test(cmd))) return true;

  // Capture any command that looks like it changes state
  if (
    /\b(install|update|upgrade|remove|delete|create|modify|write|enable|disable|deploy|migrate|backup)\b/i.test(
      cmd
    )
  ) {
    return true;
  }

  return false;
}

function scoreToolOutput(toolInput, toolOutput) {
  const cmd = (toolInput?.command || "").toLowerCase();
  let importance = 0.5;

  // Service operations
  if (/systemctl|service\s|docker/.test(cmd)) importance = 0.8;
  // Deploy/release
  if (/deploy|push|publish|release/.test(cmd)) importance = 0.9;
  // Config changes
  if (/\.env|\.conf|\.service|config/.test(cmd)) importance = 0.75;
  // Git operations
  if (/git\s+(push|merge|tag)/.test(cmd)) importance = 0.8;
  // Security operations
  if (/ufw|iptables|certbot|chmod|chown/.test(cmd)) importance = 0.8;
  // Error in output
  if (/error|fail|denied|crash|killed|refused/i.test(toolOutput || "")) {
    importance = Math.max(importance, 0.85);
  }

  return importance;
}

const afterToolCallHook = async (event, ctx) => {
  // Event shape varies — handle both possible structures
  const toolName = event.toolName;
  const toolInput = event.params || {};
  const toolResult = event.result || event.error || "";
  const toolOutput =
    typeof toolResult === "string" ? toolResult : JSON.stringify(toolResult);

  if (!toolName) return;
  if (!shouldCapture(toolName, toolInput)) return;

  const workspaceDir = ctx?.workspaceDir || DEFAULT_WORKSPACE_DIR;
  const agentId = getAgentId(workspaceDir);

  const importance = scoreToolOutput(toolInput, toolOutput);
  const cmd = (toolInput.command || toolName).slice(0, 200);

  // Truncate output intelligently — keep first and last portions
  let output = toolOutput;
  if (output.length > 2000) {
    const head = output.slice(0, 1200);
    const tail = output.slice(-600);
    output = `${head}\n...[truncated ${output.length - 1800} chars]...\n${tail}`;
  }

  const memoryText = `[Tool: ${toolName}] Command: ${cmd}\nOutput: ${output}`;

  try {
    const res = await fetch(`${MEMORY_API}/store`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-Key": MEMORY_API_KEY,
      },
      body: JSON.stringify({
        text: memoryText.slice(0, 3000),
        category: "tool_output",
        importance,
        agent: agentId,
      }),
      signal: AbortSignal.timeout(5000),
    });

    if (res.ok) {
      console.warn(
        `[after-tool-call] captured: ${cmd.slice(0, 80)} (imp=${importance}, agent=${agentId})`
      );
    } else {
      console.warn(
        `[after-tool-call] API error ${res.status}: ${cmd.slice(0, 60)}`
      );
    }
  } catch (err) {
    console.warn(`[after-tool-call] capture failed: ${err.message}`);
  }
};

export default afterToolCallHook;
